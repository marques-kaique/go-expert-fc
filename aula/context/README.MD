# üß† Context em Go --- Cancelamento, Timeout e Propaga√ß√£o

O pacote `context` do Go fornece uma forma padronizada de controlar
**deadlines**, **cancelamentos** e **metadados** durante a execu√ß√£o de
opera√ß√µes --- especialmente em aplica√ß√µes HTTP, servi√ßos distribu√≠dos e
chamadas externas.

Ele √© amplamente usado para evitar opera√ß√µes presas, liberar recursos
corretamente e interromper tarefas quando o cliente desconecta.

------------------------------------------------------------------------

## üîç O que √© um Context?

Um `context.Context` √© um objeto imut√°vel que carrega:

  -------------------------------------------------------------------------
  Recurso            Descri√ß√£o
  ------------------ ------------------------------------------------------
  **Deadline**       Quando a opera√ß√£o deve expirar

  **Cancelamento**   Permite abortar opera√ß√µes encadeadas

  **Valores**        Dados que viajam junto com a requisi√ß√£o (usado com
                     cuidado)

  **Propaga√ß√£o**     Quando um contexto √© cancelado, todos os filhos tamb√©m
  -------------------------------------------------------------------------

üëâ *O Context √© sempre passado como primeiro par√¢metro em fun√ß√µes longas
ou que fazem I/O.*

``` go
func Processar(ctx context.Context) error { ... }
```

------------------------------------------------------------------------

## ‚ú® Tipos de Context

Go fornece fun√ß√µes para criar Contexts com diferentes comportamentos:

  ----------------------------------------------------------------------------
  Fun√ß√£o                     Para que serve
  -------------------------- -------------------------------------------------
  `context.Background()`     Contexto vazio/raiz (preferido em servidores)

  `context.TODO()`           Quando voc√™ ainda n√£o sabe qual contexto usar

  `context.WithCancel()`     Permite cancelamento manual

  `context.WithTimeout()`    Cancela automaticamente ap√≥s uma dura√ß√£o

  `context.WithDeadline()`   Cancela em um hor√°rio espec√≠fico

  `context.WithValue()`      Adiciona valores (use com modera√ß√£o)
  ----------------------------------------------------------------------------

------------------------------------------------------------------------

## üìò Como Context funciona internamente

Sempre que um contexto √© cancelado:

-   Todos os contextos-filho s√£o cancelados automaticamente
-   Todas as goroutines ouvindo `<-ctx.Done()` s√£o finalizadas
-   Erros s√£o propagados pela fun√ß√£o `ctx.Err()`

Isso evita goroutines zumbis e deadlocks.

------------------------------------------------------------------------

# üåê Exemplos HTTP na pr√°tica

## üöÄ 1. Cancelando uma opera√ß√£o quando o cliente desconecta

``` go
func handler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()

    select {
    case <-time.After(5 * time.Second):
        fmt.Fprintln(w, "Processo finalizado com sucesso!")
    case <-ctx.Done():
        fmt.Println("‚ùå Cliente desconectou ou cancelou a requisi√ß√£o:", ctx.Err())
        return
    }
}
```

------------------------------------------------------------------------

## ‚è≥ 2. Timeout na requisi√ß√£o HTTP (server-side)

``` go
func handler(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
    defer cancel()

    select {
    case <-time.After(3 * time.Second):
        fmt.Fprintln(w, "Finalizado!")
    case <-ctx.Done():
        http.Error(w, "Timeout atingido", http.StatusGatewayTimeout)
    }
}
```

------------------------------------------------------------------------

## üåç 3. Requisi√ß√£o HTTP externa + Context

``` go
func handler(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), 1*time.Second)
    defer cancel()

    req, _ := http.NewRequestWithContext(ctx, "GET", "https://httpbin.org/delay/3", nil)

    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        fmt.Fprintf(w, "Erro: %v", err)
        return
    }

    fmt.Fprintln(w, "Status:", resp.StatusCode)
}
```

------------------------------------------------------------------------

## üíæ 4. Passando valores com Context (mas com cautela!)
N√£o √© muito recomendavel devido n√£o saber o que possui dentro do contexto, a melhor forma √© passar como parametro
√â igual um map, usando key e value, nesse caso a key ser√° "userID" e value "42"

``` go
type key string

func handler(w http.ResponseWriter, r *http.Request) {
    ctx := context.WithValue(r.Context(), key("userID"), 42)
    Processar(ctx)
}

func Processar(ctx context.Context) {
    fmt.Println("User ID:", ctx.Value(key("userID")))
}
```

------------------------------------------------------------------------

# üîê Boas Pr√°ticas com Context

‚úî Use `context.Background()` na inicializa√ß√£o da aplica√ß√£o\
‚úî Sempre passe o context como **primeiro par√¢metro**\
‚úî Sempre chame `cancel()` para contextos com timeout/cancel\
‚úî Nunca armazene contextos em vari√°veis globais\
‚úî Evite usar `context.WithValue` para dados complexos

------------------------------------------------------------------------

# üìé Recursos √∫teis

- [Documenta√ß√£o oficial](https://pkg.go.dev/context)
- [Effective Go](https://go.dev/doc/effective_go#contexts)
- [Go blog](https://go.dev/blog/context)
